# ABC045
Atcoder Beginner Contest045の自分の解答

Dが解けない……うぎぎ

# A
ノーコンパイルチャレンジ成功。

# B
めんどくさい問題だった。おそらく書き方が悪い。

たかだかターン数は300ターンしかないので愚直にシミュレーションしたほうがよいが、その遷移がなかなか複雑。

何度も同じ作業をするのでdfsを使ってシミュレーションする。おそらく入力の配列を2次元配列にするとスマートになったか。

# C
おそろしくめんどくさい問題だった。

文字数の長さが10文字以内なので明らかに全探索。しかしsubstr,atoiを使うかあらかじめ数字に直しておくかは悩むところ。多分substrを使ったほうが速かった。

文字列を切る位置をbit全探索などですべて列挙し、切ったものを数字に直してすべて加算していく。求めるものはすべての組み合わせの和なので切ったそばから足していっても全く問題ない。

bit全探索や1桁ずつ取り出す作業を長らくやっていなかったので大変難航した。

# D
おそらく黒く塗られたマス目に注目してその周囲24マスほどを見る問題なのだが、その処理がどうしてもO(N^2)かかってしまうので考察が頓挫した。

制約が大きいためこの手の問題で使える累積和法が使えない。そこで黒く塗られた部分に着目し、その周囲のみマス目を構築して累積和法を行い、9マス中何マス塗られているかを周囲9通りについてそれぞれ求める。これをすべての黒く塗られた部分を中心にした行う。

こうすると塗られている部分だけを抽出することができる。ただし、nマス塗られている部分については、n-1回重複して数えていることに注意する。全体で組み合わせは(h-2)\*(w-2)だけあるので、ここから塗られている組の個数を引くことで塗られていない部分を数え上げることができる。

### 追記（解説見た）
方針は間違ってなかった。1マス黒く塗ったときたかだか9箇所の範囲が少なくとも1マス以上黒く塗られることが確定する。あとは、それをmapなりソートなりでこれをまとめあげれば黒く塗られたものについてはどのくらい黒く塗られたかが確定する。黒く塗られていないものに関しては先と同じである。

解説では3\*3の範囲の中で左上のマスを起点としたものになっていたが別に真ん中でも構わない。塗られた部分を確定させる作業においてはfor文の条件に注意する（long longが絡むとややこしくなりがち。変なエラー出たら型キャストとstd:algorithmを疑う）。今回は解説に則って左上を基準とした。

ところで、これまでずっと思い込みでmapのvalueには定数の上書き処理しかできない、すなわち加算や減算などはできないと思っていた。今回加算処理を実装させる必要性が出てきたので`map[hoge]=map[hoge]+1`と書いてテストしたところ（こことは関係ない部分でいろいろあったが）無事加算処理が実装できた。`map[hoge]++`でもできるようだ。 **「mapの加算処理はできる」** ということを覚えておきたいのでテストプログラムを付属させておいた。**ただし最初からkeyでソートされている代わりにvalueでソートできない**。