# ABC121
Atcoder Beginner Contest121の自分の解答

ストレート全完

# B
全探索で間に合うのは当たり前なんだけど制約次第で化けそう。

今回はABノーコンパイル提出成功した。

# C
安いところから貪欲に買っていく。

まず栄養ドリンクの価格昇順にソートし、M本を上回るまで価格を加算し続ける。基本的に参照した店の栄養ドリンクは全部買う。もしM本を上回ってしまったら上回った分はすべて現在参照している店で買ったものなので買いすぎた分を価格から引く。これは買った栄養ドリンクの本数の累積和をnowと置くとnow-Mで求められる。

# D
実際に書き出して各ビットごとに注目すると、iビット目はi個ごとに1と0が入れ替わっている、すなわちまとまりと法則性を持って並んでいることがわかる。

まず0と1の周期をひとつのまとまりとして置き、aとbがそれぞれどのまとまりに属すか、\[a,b\]には何個分の完全なまとまり(00000....111111....)を最低限含むかを求める。これは累積和の要領で（bが何番目のまとまりか）-（aが何番目のまとまりか）で求められ、実際にはiビット目のまとまりの数を求めたいとすると`floor(b/(i*2))-floor(a/(i*2))`で求まる。

これはあくまで「aが属しているまとまりからbが属しているまとまりのひとつ手前のまとまり」までの1の個数を表していることに注意する。つまりa近傍では多めに見積もっており、b近傍では少なめに見積もっている可能性がある。これを補正する。

0と1の分かれ目になっているのはちょうどまとまりの中でi番目に当たる位置である。したがってi\*2を法としたmodをaに対して求めたときaがiより大きくなっているなら過剰な数え上げが起きている。この個数は`a%(i*2)-i`で求まる。bの場合も同じようにして`b%(i*2)-i+1`で補正できる。a側の区間は端、つまりちょうどaを含まないので（補正で引かれる部分だから）1加える必要はないが、bはちょうどbもちょうどiも含むので1加える必要がある点に注意する。

以上の処理を全ビットについて行って全ビットについて1の個数を記録し、奇数なら対応するビット演算を行って答えに加える。このとき**通常のビット演算記法では32bitまでしか記述できずオーバーフローする**ことに注意する。

オーバーフローを回避しつつビット演算を記述するには以下のようにする。

```cpp
ll sum=0; //当然合計部分は64bit
for(int i=0;i<64;i++)//ここはintでもオッケー
{
	if(sum[i]%2==1)
		sum+=1LL<<i;//ここの1を明示的に64bitにしなければならない
}
```