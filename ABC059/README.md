# ABC059
Atcoder Begginer Contest 059の自分の解答

# A
どうやって大文字小文字判定しようと考え、STLのtransform関数を使おうとしたらなぜか使えなくて相当焦った。同じくSTLのtoupper関数を使うことで解決した。

しかし、解説を読むとそもそも入力はすべて小文字であることが判明。上記の焦りや工夫は水泡に帰したのであった（すべて小文字であることが分かっているなら足し算すれば良い）。

# B
入力の最大値が10^100なので明らかに整数型の範囲ではない。したがって文字列型を使って比較していくしかないのだが、AとBの入力桁数が違った場合何らかの形で桁数を揃えないと正しく比較できない。ここでは、入力文字列を逆転することで必ず数字の並びが1の位、10の位、100の位……、10^100の位となることを利用し、逆転して10^100の位まで後ろに0をつなげて100桁の数を作り、それを後ろから比較していくことで解決した。

しかしながら、よくよく考えると10^100の位って101桁目のような……なぜこれで通ったのか不思議だ。

# C
鬼のように難しい問題だった（結局WA）。条件的にはi-1項とi項に読み替えても良さそうなものだが実際にはどうなのだろうか。

和の正負をフラグによって管理し、直前の結果と正負が一致する場合は一致させないように和を変化させる（これは|i項目までの和+1|によって求まる）。これを最後まで繰り返すと最小値が得られるはずなのだが、なぜか得られなかった。

解説を読んだところ、最初を正にするか負にするかの両方の結果の最小値を取らなければならないとのこと。そんなもの最初の項に依存するだろうと思っていた完全なミス。完膚なきまでにやられた。

### 追記（解説読んだはずだがほぼ覚えてない）

i-1項目までの和を記録しておき、i項目までの和が条件を満たすにはどのようにi項目を動かせばよいかを考える。

たとえばi-1項目までの和が負でi項目までの和が負ならば、i項目までの和が1になるようにi項目を増やすのが最適となる。逆ならば-1になるようにする。それ以外は条件を満たしているので動かす必要はない（どこを動かしても全体の和は+1もしくは-1しかしないため）。

どのくらい動かせばよいかはa[i]+sum[i-1]（現在時点での和）と1 or -1（目標値）の差を取れば良い。**2値の差はabs(片側-もう片側)で大小によらず取ることができる**。

基本的にはこのように解く問題だが、最初の値を正にするか負にするかで2通りの場合分けがあるので実装はやや煩雑になった。どちらかに決め撃ちしてしまうと例えば`-2, -2, 2, -2, 2, -2`というような数列で最適解が出ない。

某所でDPを使う代表的な問題として掲載されていた記憶があるが、DPっぽいことは結局しなかった。

# D
ゲームであることからDPかなと思ったがdpテーブルの構成もうまいやり方が思い浮かばず当然漸化式もわからなかったのでお手上げ。

解説によると数学的に一意に求まるらしい。知るかボケ。
