# ABC037
Atcoder Beginner Contest037の自分の解答

変なところでハマり大量WA。

# C
素直に区間を全部足すとO(N^2)で部分点。

数列の要素について、i番目の要素が何回足されたかについて考える。例えばn=7,k=3のとき、総和を求める過程で足される回数の数列は以下のようになる。

> 1,2,3,3,3,2,1

ひとつの部分列が被覆する区間はk個なので足される回数は上限k回に抑えられる。そして、全部被覆される場合とそうでない場合の差異を考えると両端は1回足され、端から離れるごとに1ずつ加えられていくことが分かる。したがって両端から(k-1)個の区間ではk回足されず、それ以外の区間ではk回足されるということが分かる。

ここまで考察して提出するとWA。いろいろ試してみると、必ずしもk回足される区間が存在するわけではないということが分かった。

両端からk個分の位置を取ったとき、これが交差しているとk回足される区間は存在しないことになる。このとき、両端は通常と同じように1から順番に足されていき、重複している区間でインデックスの増加が止まり、その区間はすべてその回数だけ足される。

例えばn=7,k=5のとき、上記の数列を求めると以下のようになる。

> 1,2,3,3,3,2,1

……奇しくも前の数列と同じになってしまったが、このようにしてすべてのケースをカバーすることができた。

実装は比較的ややこしく思うように動かなくて苦しまされた。まずk回足される区間の左端と右端を求め、これが交差していたら（左index>右index）になっていたらk回足されないので右端までの要素数を求めて足して……と実装した。良いコードではない。

# D
確実にやり方はあっているのに何か通らない。

小さな値から順番に大きな値へとたどっていけるたどり方の総数を求める。隣接する異なる数字が合ったとき、小さい方がたどることのできるルートの一部には大きい方がたどることできるルート全てが含まれているので、大きい数字からDPっぽく行くことのできるルートの総数を求めることでうまく計算時間を短縮できる。

まず、pair\<pair\<\>\>なりtupleなりで数字とその位置を記録したデータ構造を用意し、これを降順にソートする。dpテーブルは1で初期化し（どこにも移動しないものも経路として含むので）順番に上下左右に移動できるかを調べ移動できる場合はdpテーブルを加算する。

### 追記（解説見た）
dpテーブルに対してMOD計算をしていなかったのが敗因。こういう実装のミスをどうにかしてなくしたいんだけどどうしたらいのか途方に暮れる。

あと四方を見るときdx[\]={0,1,0,-1},dy[\]={-1,0,1,0}というふうにしてforループ回す手法、非常に頭がいいので採用していきたい。