# ABC118
Atcoder Beginner Contest118の自分の解答

データ構造力が虚無

# C
Sample1をもとにいろんな数字の差を取って最小値を探ると、最小値の倍数かどうか条件に絡みそうだということがわかりさらに考察を進めたところ(4,6)のような反例が見つかった。反例をもとにすればGCDを取ればいいことが分かったので互除法実装して終わり。互除法覚えた。

forループの中身下記間違えて2WA。実質茶

# D
いかにもDPっぽそうな問題だったので遷移条件を考えた。

> dp\[i\]...i本使ったときの最大整数

とするとよさげだったので普通に実装したところ、64bitではどうやら足りないらしい。仕方がないので超面倒ながら文字列で実装していく方針に変えたが、dpテーブルの更新順の問題でうまくいかない。ここまできてようやく上のdpテーブルは最大整数ではなく最大整数を構成するときに使われる数の組であることに気づいた。したがってdp\[n\]をソートして提出→WA。

やはり更新順によって本来最大整数となるはずの組を更新してしまっているようなので、これを厳密に評価することにした。まず、tupleを使ってそれぞれの数字の個数を効率よく比較できるようにしようとしたが、tuple内の任意の要素のみ更新する方法が分からず断念。次にclassとoperatorを定義してやろうとしたが「これ結局tupleとやること変わらなくね？」となり諦め。最終的に文字列に戻りdpテーブル更新のたびにソートして比較する方法に落ち着いた。なんとなく分かってたけどこれはTLE。しかし全体の計算量はO(nklogk)でありkは長くても5000程度に抑えられることから考えても間に合うと思うのだが何か間違っているのだろうか？

### 追記（解説見た）
桁数とそこに入れる数字を別にして考えるとよいとのこと。

入れる数字の選定方法は各数字を1つ使った際の本数がわかっているのでその数字をkとすると

> dp\[i-number\[k\]\]=dp\[i\]-1

が成り立つかどうかで調べることができる。ただしこれは同じ本数使う数字については考慮されていないので数字はあらかじめ大きい順に並べておく。

DPの遷移条件については考えていたが経路復元についてはほとんど考えたことがなかった。よくよく考えると、結構なDPで経路復元によってどれをいくつ使ったか特定できそうな気がする。
