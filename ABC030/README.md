# ABC030
Atcoder Beginner Contest030の自分の解答

久々の実質全完

# C
あまり考えずに二分探索でよさそう（最大n+mステップ探索するのでO(NlogN)）と思いlower_boundで実装し、サンプルが通るも通らず。

これだからにぶたんは……と思いつつコードににらみつけるしていたら1ヵ所mとnを打ち間違えている場所が発覚。解決。アホ。

# D
制約的に必ず閉路を含み、modによる問題に帰着できるがそれをどうやるか。

まずこの問題を2つのステップに分けた。

1. 単語帳のスタート位置から閉路を検出するまで調べ、閉路1周の長さを求める
2. 入力された文字列を巨大数として解釈して任意の数でmodを取る

まず1について。1についてはそれぞれのノードから1つしか有向辺が出ないのでそのままdfsして求める。閉路に至るまでの経路のことを自分は「しっぽ」と表現したが、このしっぽの長さは最初にすでに通ったノードに戻るまでの長さとした。

次に2について。筆算と同じ要領で例えば100000%17みたいな計算は(100%17)000%17のように分割できる。このことを利用してlong longにぎりぎり収まる桁数文字列から数字を取り出してmod計算することを繰り返して巨大数のmodを求められる。

これの実装途中でわざわざこんなことしなくても1000000%17=((1%17)0%17)%17...のように1桁ずつ取り出してmod計算しても結果が同じになることに気づき、その方針で実装した。

この2つの実装を問題上で組み合わせて答えのプログラムを作成した。ところでしっぽは十分に長い可能性があり（最大10^5）、しっぽの段階でステップが終了してしまうことがある。その場合は当然閉路に入らないのでmod計算はしなくてもよい。そのことを明確に分離するために、10^8程度でkが収まっている場合はstoiで数値に直して手計算（愚直シミュレーション）を行った。

mod上において引き算はいつしても大丈夫なのでループに入る場合しっぽの分は最後に引く。そしてインデックスがマイナスにならないようにだけ注意してあらかじめとっておいた閉路の始まり（これは1の段階で初めて2回に通るノードに等しい）からこれまた手計算で求めた。この部分はvector等で順番を記録しておけば手計算しなくても済むのだが、実装上のバグを最小限に抑えるためにあえて単純な方法を採った。