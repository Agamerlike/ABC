# ABC122
Atcoder Beginner Contest122の自分の解答

なかなかしんどかったが辛勝。

# A
mapでやったけどもう少し賢い方法があるかもしれない。

# B
ノーコンパイルチャレンジ敗北。

普通に全探索をし、条件に適合する部分文字列を抽出して最大長さを取る。2重ループの半開区間\[i,j)でやる場合、jはs.size()ちょうどまで取る必要があることに注意。割とハマりやすい問題だと思う。

# C
ただの累積和。典型。

2文字目から探索し、今見ている文字と直前の文字が"AC"になっていれば累積和に1加算する。あとは書き方の問題。半開区間とお友達になりたい。

# D
DはDPのD（絶望）

> dp\[i\]\[j\]\[k\]\[l\]...i文字の文字列でi番目の文字j、i-1番目の文字k、i-2番目の文字lとしたときに条件を満たす文字列の数

上記のようなdpテーブルを考える。簡単のため文字は0:null, 1:'A', 2:'C', 3:'G', 4:'T'とした。

初期値は1文字目を与えたdp\[1\]\[a\]\[0\]\[0\]=1である。aは1～4。

ここから遷移条件を考える。まずは何も条件がなかった場合、次の状態は今考えている文字をa、直前の文字を順にb, cとするとdp\[i\]\[a\]\[b\]\[c\]+=dp\[i-1\]\[b\]\[c\]\[moji\]となる。ここでmojiはACGT(null)のうち任意の文字である。

次に除く条件を考える。現在の文字を含めて3文字保持できるので"AGC"のパターン("AGC", "GAC", "ACG")が検出された場合は問答無用で0にする（毎ループしてもよいしするべき）。これ以外に、4文字のパターンで除かなければならないものがある。例えば"AGTC"のような文字列はTとCを入れ替えることで"AGC"になってしまううえ、先程の"AGC"のパターンでは検出されない。同様に"ATGC"も検出されない。したがってこの2つ"AG?C"と"A?GC"を除く（?はnull除く任意の1文字）。このとき"AGC"パターンを二重に引いてしまうと厄介なことになるので"AGC"パターンは細心の注意を払って0にしておかねばならない。

ここまで50分近くかけて実装してn=4の計算が合わない。これまでには3次元DPでやろうとして失敗したり紆余曲折あった（ダメ）。

よくよく考えると"AG?C"と"A?GC"は?がGの場合かぶってしまうケースがあることが分かった。これをうまくつじつま合わせて("AGGC"のパターンを引いたあとで1回足せばよい)出したら通った。

また、複数回"AG?C"等の調整をしないために4次元配列のフラグ変数を作った。これは変数名mにしたらコンパイルが通りminusにしたらコンパイルが通らなかった。謎。