# ABC062
Atcoder Begginer Contest 062の自分の解答

# A
ひでえ問題だ。規則性がない以上グルーピングは力技で行うしかない。色々やり方はあると思うが、自分は文字列型の配列を使った。連想配列とかでもいけるだろう。

# B
以前の画像の一部検索問題よりも簡単。まずは上と下にH+2分の\#を出力し、実際に文字を入力した部分には文字列型演算子とinsert関数を使って前と後ろに\#を追加する。かなり簡単。

# C
アルゴリズム的には合っていたとしか考えられないが、どこか変なところで引っかかり結局解けず。

まず縦と横を入れ替えても答えは変わらないので横の長さのほうが長くなるように並べ替えておく。そしてあとはひたすら場合分けによって解く。

縦と横のどちらかが3で割り切れる場合は明らかに0。また、縦と横の両方が3未満になる場合（つまり2\*2）1が答え。残りの場合についてだが、切り分け方は以下の3通りに分かれる。

* 横が1:2に近くなる位置で切り分け、2の方を縦の半分の位置で切る（1のほうの2倍が2のほうより小さい）

* 横が1:2に近くなる位置で切り分け、2の方を縦の半分の位置で切る（1のほうの2倍が2のほうより大きい）

* すべて縦に切り分ける

すべて縦に切り分けた場合、答えは縦の長さとなる。残り2つの場合についてだが、これは3で割り切れないとき余りを切り捨てるか切り上げるかで場合分けを行っている。これは効率良く求める方法はないので素直に求める。最後にこれら3つの求め方で求めた答えの中から最小値を取る。

# D
部分点があること、入力が膨大なこと、普通に解くとO(2^n)かかることを考慮して、DPであると推測を立てたが、部分問題が全体問題の解になっていないのでよく分からなかった。

### 追記（もう覚えてないけど解説見た）

この問題は任意のn個を取り除く問題ではなく、任意の場所で区切って、左側の区間からn個、右側からn個取り出す問題と言い換えることができる。左側は大きいものn個、右側は小さいものn個取り出せば良いので、逐次ソートを行えば実現できる。

以上のアルゴリズムをソートで実現した場合、O(n^2logn)となり、nが10^5だとかなり厳しい（部分点は取れる）。したがってソートと取り出しをより最適化できるようなデータ構造、すなわちpriority_queueを使ってこの部分を実装する。

priority_queueは何も指定しなかった場合は降順ソートされている。ここから小さいものをk番目まで取り出したいときには、最初にpushしたものを全部足しておき、そこからn-k回popした分を引けばよい。

Win環境下ではfunctionalをインクルードすることでgreaterが使えるので、そちらを使うのも良い（多分こっちのほうが楽）。