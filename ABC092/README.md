# ABC092
Atcoder Beginner Contest092の自分の解答

# A
今日はコンパイルせずに通せた。問題の意味を取るのにやや手こずった。

# B
i人目の参加者が取るチョコの数はceil(d/a[i])でいけそうだったのでそのように実装したら通った。証明はしない。

# C
迷走したが何とか正解にたどり着く。

普通に実装するとO(N^2)となり間に合わないので、O(N)にする方法かO(NlogN)にする方法を探した。

経路のパターンはN通りしか存在せず、かつほとんどの部分においてその経路は共通している（具体的にはスキップする場所以外）。またスキップする部分単体はO(N)で求まる。つまり、以下のように求めることで高速に求められそうだということが分かる。

(0からi-1番目までの共通する部分)+(i-1番目からi+1番目にスキップする部分)+(i+1番目から戻ってくるまでの共通する部分)

共通部分を求めるには、累積和を用いる。その場合、配列にスタート地点とゴール地点を加えておく。これでO(N)になった。

# D
分かりそうだったが時間が足りなかったので断念し、またその後実装を行ったが不正解だった。

a=bの場合、格子状に埋めることで問題の条件を達成できる。したがってmin(a,b)分は格子状に埋めてしまってよい。

差分をどうやって補充するかが焦点となる。格子状に埋め尽くしたところに例えば'#'だけ1つ分加えたいとする。このとき、以下のようにすれば加えられることが分かる。

```
#.#.#.#.#.#.#.
.#............
```

```
.#.#.#.#.#.#.#
..#...........
```

それ以外のパターンについても同様である。したがってこの方式で問題の条件を満たすことができる。

しかし、h,w\<=100という条件があるため、aとbの差が大きすぎると条件にそぐわない場合がある。したがって、どのような場合でもw=100となるように調整する。そうすると端っこの条件が変わってくるのでそのための例外処理を実装して……とやると時間がなくなった。