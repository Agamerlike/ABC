# ABC036
Atcoder Beginner Contest036の自分の解答

1完。まあ普通。

# C
ややこしいと思うのだが、これぐらいがCの標準難度なのかもしれない。

配列aの要素に小さいものから順番に番号を振ってください、という問題。ソート時に数字とインデックスを同時に持っておく必要があるのでpair\<int,int\>の出番。また同じ数字には同じ番号を振ることができるので直前と数字が同じなら同じ番号を割り当てるようにする。

pair使わない場合O(N^2)なので60点分の部分点解になる。

# D
2彩色グラフの応用。2彩色っぽく1つずつ貪欲にやる→1つ飛ばしで貪欲にやる……というように2彩色をしながら白の範囲を徐々に広げていくという方法を考察したが数が足りなかった。またこの方法だと最悪2^(10^5-1)を計算する必要があるので現実的でない。

次に隣接する色が確定したノードに注目する方法を考えた。隣接したノードの色が白ならこのノードも白と黒の両方を取ることができる。黒なら白しか取ることができない。このことに注目して手前のノードに依存するDPを考えたが、これも数が足りなかった。枝分かれがないグラフならこれで正答が取れると思われるが……

### 追記（解説読んだ）
木の子ノード（を親とする部分木）に注目して親との色の関係に注目すればうまくDPが構成できる。

今見ているノードに子がk個あるとする。またノードxが白のときの部分木の塗り分け方をf(x)、黒のときの部分木の塗り分け方をg(x)とする。

まずxが黒の場合を考える。黒の場合子ノードは必ずすべて白となるので`g(x)=f(x_1)*f(x_2)*...*f(x_k)`となる。

次にxが白の場合を考える。白の場合子ノードは白でも黒でも良いので`f(x)={f(x_1)+g(x_1)}*{f(x_2)+g(x_2)}*...*{f(x_k)+g(x_k)}`となる。どうせ後に加算することになるのでf(x)はノードxが親となる木の塗り分け方の総数`h(x)=f(x)+g(x)`として定義したほうが都合が良いかもしれない。

**独立であることを忘れていて足し算でやっていた。また親ノードを間違えて計算してしまうなどのミスが目立った。**

このグラフは木なので任意の葉からたどっていくことですべての場合を網羅できる（枝分かれがある場合はその都度加算する）。このDPを適当な葉からスタートして全てのノードを経由するまで実行するとできそうだ。

実際には葉に初期値を定め、それ以外のノードにおいてはdfsで求めた。最後にdfsを実行したノードが根である。

こういうDPをtree DPというらしい（木の上でのDPなので）。前に属していた集合をすべて使うという観点からはbitDPによく似ていると感じた。
